I"É<p>As we‚Äôve continued to grow <a href="http:joltsensor.com">Jolt</a>, we‚Äôve found it useful to build internal tools for tracking sales and engagement. Specifically, identifying and monitoring key geographies where we‚Äôre doing well helps in understanding our customers and targeting new ones. In this example, I‚Äôll share how we make a bubble map of sales volume by US zip code. The bubbles are scaled proportionally to the total profit for the area and centered on the centroid of the zip code region.</p>

<div id="chart">
	<div id="pane-1" class="pane">
	</div>
	<div id="pane-2" class="pane">
	</div>
</div>

<p>The inspiration for this map was Mike Bostock‚Äôs tutorial <a href="https://bost.ocks.org/mike/bubble-map/">Let‚Äôs Make a Bubble Map</a>, however we put in some additional work on data collection and cleaning, interactive tooltips for exploring the data, and making everything responsive. Here‚Äôs the general process that we followed to make the map above:</p>

<ul>
  <li>Export a sampling of recent sales data from <a href="https://www.trycelery.com/">Celery</a> and a sampling of backers from <a href="http://joltsensor.com/kickstarter">our Kickstarter campaign</a></li>
  <li>Use a <a href="https://www.python.org/">Python</a> script to aggregate this data by zip code and combine it with demographic data for each zip code pulled from the <a href="http://www.census.gov/data/developers/data-sets.html">US Census API</a></li>
  <li>Use a Makefile to download and prepare the proper geographic shapefiles from the US Census Bureau‚Äôs <a href="https://www.census.gov/geo/maps-data/data/tiger.html">TIGER database</a></li>
  <li>Use <a href="https://d3js.org/">D3</a> to draw the map, plot the zip-code-level data points, and provide interactive ways to explore the data</li>
</ul>

<h3 id="preparing-the-data">Preparing the Data</h3>

<p>If you‚Äôre building a visualization like this into some sort of internal dashboard, it probably makes sense to connect it to an API that serves up fresh data (if you have one available). But for the purposes of this tutorial, I‚Äôm going to focus on working with the sales data locally, outputting a final .csv file for D3 to read in.</p>

<h4 id="downloading-sales-data-from-celery-and-kickstarter">Downloading Sales Data from Celery and Kickstarter</h4>

<p><em>Skip to the next section if you already have the data you need, already know how to get it, or are getting it from other sources.</em></p>

<p>Downloading data for Jolt was straightforward. On Kickstarter, navigate to your project, click ‚ÄúMenu‚Äù in the upper righthand corner of your project page, and select ‚ÄúView backer report‚Äù. At the top of this page, there‚Äôs a link to ‚ÄúExport backer report‚Äù. It triggers a pop-up that allows you to select the output format. I selected ‚ÄúAll Tiers‚Äù and ‚ÄúKickstarter - pledges, surveys, addresses‚Äù. When you click ‚ÄúExport‚Äù, it takes a few seconds to prepare the files for download and then displays a ‚ÄúDownload‚Äù button when ready. After downloading the report, I unzipped it, deleted all but a few rewards tiers I wanted to include, and then copy-pasted their data into a single file. Note that it‚Äôs important to make sure the files you‚Äôre combining have the same column headers and order. If they don‚Äôt you‚Äôll want to use a script to merge them properly.</p>

<p>Following our Kickstarter campaign, we used Celery to collect pre-orders and have continued to use it for order collection now that we‚Äôre shipping. To get export sales data from Celery, simply navigate to your ‚ÄúOrders‚Äù page while logged in. Apply whatever filters you‚Äôd like (for example, date range and product variant) and click the ‚ÄúExport Orders‚Äù button at the upper right of the page. Then select ‚ÄúExport Fulfillment CSV‚Äù in the pop-up (since we want address data to work with). This downloads a .csv that‚Äôs good to go, unless you want to apply additional filters to the data.</p>

<h4 id="initializing-git">Initializing Git</h4>

<p>Now that you might have some somewhat sensitive company information (along with personal information of your customers) on your machine, it‚Äôs a good time to set up a <code class="highlighter-rouge">.gitignore</code> file if you‚Äôre going to be using <a href="https://git-scm.com/">Git</a> to manage your work on this project. In your terminal, navigate to the folder where you‚Äôre keeping your work for this project and run the following command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init
</code></pre></div></div>

<p>Now, create your <code class="highlighter-rouge">.gitignore</code> file in the same directory to make sure you don‚Äôt accidentally check in those sensitive files or other generated files. Mine looked like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.DS_Store
build
node_modules
api_keys.json
orders.csv
kickstarter.csv
</code></pre></div></div>

<p>The <code class="highlighter-rouge">build</code> and <code class="highlighter-rouge">node_modules</code> are where references and generated files will be stored that we don‚Äôt need to track with git, as they can be regenerated at any time. And <code class="highlighter-rouge">api_keys.json</code> is where I keep my keys for the Census Data API (<a href="http://api.census.gov/data/key_signup.html">get key</a>) and Google Maps Geocoding API (<a href="https://developers.google.com/maps/documentation/geocoding/get-api-key">get key</a>) for reference by the Python script that we‚Äôre about to get into. The file looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"google": &lt;API key here in quotes&gt;,
	"census": &lt;API key here in quotes&gt;
}
</code></pre></div></div>

<h4 id="processing-the-data-with-python">Processing the Data with Python</h4>

<p>If you‚Äôre going to be copying parts of this Python code verbatim for your own use, make sure you have Python 3 installed on your machine. You can download that <a href="https://www.python.org/downloads/">here</a>. We‚Äôll start by importing the modules that we‚Äôre going to use.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import urllib.request, ast, csv, json
</code></pre></div></div>

<p>The <code class="highlighter-rouge">csv</code> and <code class="highlighter-rouge">json</code> modules are useful for reading and writing files of those respective types, <code class="highlighter-rouge">urllib</code> is what we‚Äôll be using to make API calls, and <code class="highlighter-rouge">ast</code> will allow us to parse the responses from those requests into a usable format. The first thing we want to do is to read in the sales data and aggregate order totals by zip code. Before we read it in, we‚Äôll define a class that we‚Äôll use instances of to store zip code areas and their corresponding data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Area:

	def __init__(self, zipcode, total):
		self.zipcode = zipcode
		self.total = total

	def add_info(self, lat, lng):
		self.lat = lat
		self.lng = lng

	def add_demos(self, queries):
		self.demos = []
		for item in queries:
			self.demos.append(item)
</code></pre></div></div>

<p>For now, you can ignore the <code class="highlighter-rouge">add_info</code> and <code class="highlighter-rouge">add_demos</code> methods, as we won‚Äôt be using them until we start pulling Google and Census data. The <code class="highlighter-rouge">__init__</code> method will be invoked automatically by instantiation of a new class instance. Now, after creating an empty array <code class="highlighter-rouge">orders</code> to hold all of the <code class="highlighter-rouge">Area</code> instances we‚Äôll be creating, we‚Äôre ready to read in our Kickstarter order data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>orders = []

with open('kickstarter.csv', newline='') as csvfile:
csv_f = csv.reader(csvfile)
for row in csv_f:
	if row[4] == 'US':
		code = row[19].split('-')[0]
		amount = float(row[8][1:-4])
		if code != '':
			added = False
			for order in orders:
				if order.zipcode == code:
					order.total += amount
					added = True
			if added == False:
				orders.append(Area(code, amount))
</code></pre></div></div>

<p>What we‚Äôre doing here is opening the <code class="highlighter-rouge">kickstarter.csv</code> file and reading through it row by row. We first check index <code class="highlighter-rouge">[4]</code> to verify that the shipping country is the United States (since that‚Äôs the only region we‚Äôre mapping). Then we get the five digit form of the zip code from index <code class="highlighter-rouge">[19]</code> and parse the order total at index <code class="highlighter-rouge">[8]</code> into a usable format. Kickstarter exports order totals in the form ‚Äú$110.00 USD‚Äù, so <code class="highlighter-rouge">row[8][1:-4]</code> is how we access everything between ‚Äú$‚Äù and ‚Äú USD‚Äù. With the order info extracted, we check to see if there‚Äôs already an <code class="highlighter-rouge">Area</code> instance in the <code class="highlighter-rouge">orders</code> array with a matching zip code. If there is, we increment <code class="highlighter-rouge">order.total</code> by the amount of the order. If not, we append a new <code class="highlighter-rouge">Area</code> instance for the zip code to the array.</p>

<p>We import <code class="highlighter-rouge">orders.csv</code> in the same way, updating the query indexes to match its formatting.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>with open('orders.csv', newline='') as csvfile:
	csv_f = csv.reader(csvfile)
	for row in csv_f:
		if row[30] == 'US':
			code = row[29].split('-')[0]
			amount = float(row[12])
			added = False
			for order in orders:
				if order.zipcode == code:
					order.total += amount
					added = True
			if added == False:
				orders.append(Area(code, amount))
</code></pre></div></div>

<p>At this point, we have an array <code class="highlighter-rouge">orders</code> containing an <code class="highlighter-rouge">Area</code> instance for each zip code that we received an order from, along with the total dollar-value of orders from each locale. Now we‚Äôre ready to add some context, first using the Google Maps Geocoding API to get the latitude and longitude of each zip code‚Äôs center point, then using the US Census API to get some basic demographic information on each area. We define a class for each API, each with an <code class="highlighter-rouge">__init__</code> method to pull in our API key and a <code class="highlighter-rouge">get</code> method to create a properly formatted API call, execute it, and return the results.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ZipInfo:

	def __init__(self, key):
		self.key = key

	def get(self, query, file_type='json'):
		url = 'https://maps.googleapis.com/maps/api/geocode/%s?address=%s&amp;key=%s' % (file_type, query, self.key)
		req = urllib.request.Request(url)
		response = urllib.request.urlopen(req)
		return response.read()

class Census:

	def __init__(self, key):
		self.key = key

	def get(self, fields, geo, year=2014, dataset='acs5'):
		fields = [','.join(fields)]
		base_url = 'http://api.census.gov/data/%s/%s/profile?get=' % (str(year), dataset)
		query = fields
		for item in geo:
			query.append(item)
		add_url = '&amp;'.join(query)
		key_url = '&amp;key=' + self.key
		url = base_url + add_url + key_url
		req = urllib.request.Request(url)
		response = urllib.request.urlopen(req)
		return response.read()
</code></pre></div></div>

<p>Next, we read in our API keys from our untracked <code class="highlighter-rouge">api_keys.json</code> file, store them in variables, use them to instantiate instances of our API classes, and create an array of the demographic queries we‚Äôll be passing to the Census API. You can see a full list of the available census data variables for the 5-Year American Community Survey <a href="http://api.census.gov/data/2014/acs5/profile/variables.html">here</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>with open('api_keys.json') as json_data:
	d = json.load(json_data)
	api_key_c = (d['census'])
	api_key_g = (d['google'])

c = Census(api_key_c)
z = ZipInfo(api_key_g)

query_for = [
	'DP05_0001E',	# total population
	'DP05_0017E',	# median age
	'DP05_0032PE',	# race:white (%)
	'DP03_0062E',	# median household income
	'DP02_0064PE',	# bachelors degree (%)
	'DP02_0065PE'	# graduate degree (%)
	]
</code></pre></div></div>

<p>With everything set up and ready to go, we can now loop through the <code class="highlighter-rouge">orders</code> array, making two API calls for each zip code. The first returns the latitude and longitude, which we save to each <code class="highlighter-rouge">Area</code> instance using the <code class="highlighter-rouge">add_info</code> method we previously created. And the second return our census data queries, which we add using the <code class="highlighter-rouge">add_demos</code> method.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for order in orders:
	info = z.get(order.zipcode)
	results = ast.literal_eval(info.decode('utf8'))
	lat = results['results'][0]['geometry']['location']['lat']
	lng = results['results'][0]['geometry']['location']['lng']
	order.add_info(lat, lng)
	info = c.get(query_for, ['for=zip+code+tabulation+area:'+order.zipcode])
	try:
		results = ast.literal_eval(info.decode('utf8'))
	except:
		for x in range(0, len(query_for)):
			demos.append('null')
		order.add_demos(demos)
		continue
	else:
		demos = []
		for x in range(0, len(query_for)):
			demos.append(results[1][x])
		order.add_demos(demos)
</code></pre></div></div>

<p>Our last step in Python is to save all of this data to a file that we can access with D3. The syntax and process are very similar to when we previously <em>read</em> files, but now we‚Äôre <em>writing</em> data row by row.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>with open('orders_demos.csv', 'w') as output:
	writer = csv.writer(output, lineterminator='\n')
	writer.writerow(['Zipcode','Profit','Lat','Lng','Population','Median-Age','Race-White','Median-Household-Income','Bachelors-Degree','Graduate-Degree'])
	for order in orders:
		writer.writerow([str(order.zipcode), str(order.total), str(order.lat), str(order.lng), str(order.demos[0]), str(order.demos[1]), str(order.demos[2]), str(order.demos[3]), str(order.demos[4]), str(order.demos[5])])
</code></pre></div></div>

<p>Save the completed file (we called ours <code class="highlighter-rouge">orders.py</code>) to your project directory, open your terminal, navigate to the project directory, and execute the following command.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 orders.py
</code></pre></div></div>

<p>Depending on how much order data you‚Äôre processing, it may take a little while to run (and you may want to add in some <code class="highlighter-rouge">print()</code> statements to track its progress). When it finishes, you‚Äôll see a new (or updated) <code class="highlighter-rouge">orders_demos.csv</code> file in your project directory.</p>

<h3 id="preparing-map-files">Preparing Map Files</h3>

<p>With all of our order/demographic data prepared, we now need the map files to generate the maps that the data will be plotted on.</p>

<h4 id="downloading-topojson">Downloading TopoJSON</h4>

<p>From its documentation, ‚ÄúTopoJSON is an extension of GeoJSON that encodes topology‚Äù. To avoid getting in the weeds and rehashing what others have explained well elsewhere, I‚Äôll just say that TopoJSON is how we convert the map shapefiles (geospatial vector data) into JSON that we‚Äôll render with D3. To keep things trackable and repeatable, make a <code class="highlighter-rouge">package.json</code> file that will be used to install dependencies.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"name": "anonymous",
	"private": true,
	"version": "0.0.1",
	"dependencies": {
		"topojson": "1"
	}
}
</code></pre></div></div>

<p>Now run <code class="highlighter-rouge">npm install</code> in your project directory, and everything you need to work with TopoJSON will be stored in <code class="highlighter-rouge">/node_modules</code>.</p>

<h4 id="creating-the-makefile">Creating the Makefile</h4>

<p>Similar to using <code class="highlighter-rouge">package.json</code>, we‚Äôll now create a Makefile rather than executing our next few steps directly in terminal. This makes things easier for us while working on the project, with the additional benefit of better documentation. In your project directory, create a file called <code class="highlighter-rouge">Makefile</code> with the following contents.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: us.json

clean:
	rm -rf -- us.json build

.PHONY: all clean

build/cb_2015_us_state_20m.zip:
	mkdir -p $(dir $@)
	curl -o $@ http://www2.census.gov/geo/tiger/GENZ2015/shp/$(notdir $@)

build/cb_2015_us_state_20m.shp: build/cb_2015_us_state_20m.zip
	unzip -od $(dir $@) $&lt;
	touch $@

build/states.json: build/cb_2015_us_state_20m.shp
	node_modules/.bin/topojson \
		-o $@ \
		-- states=$&lt;

us.json: build/states.json
	node_modules/.bin/topojson-merge \
		-o $@ \
		--in-object=states \
		--out-object=nation \
		-- $&lt;
</code></pre></div></div>

<p>In the interest of not reinventing the wheel, <a href="https://bost.ocks.org/mike/bubble-map/#finding-boundaries">Mike Bostock explains</a> what all of this means (and does) as clearly and succinctly as one could. All you need to know here is this: once you‚Äôve created the <code class="highlighter-rouge">Makefile</code>, executing <code class="highlighter-rouge">make build</code> in terminal will create the <code class="highlighter-rouge">us.json</code> file that you‚Äôre going to feed D3. And executing <code class="highlighter-rouge">make clean</code> will delete that file, as well as the <code class="highlighter-rouge">/build</code> folder containing the downloaded files referenced to build it.</p>

<h3 id="mapping-the-data">Mapping the Data</h3>

<h4 id="setup">Setup</h4>

<p>With all of the data prep out of the way, we‚Äôre <em>finally</em> ready to start building our visualization in D3! While some people will put all of the code for their visualization in a single HTML file, using <code class="highlighter-rouge">&lt;script&gt;</code> and <code class="highlighter-rouge">&lt;style&gt;</code> tags, I prefer to break things out into individual files to keep things decluttered. In your project directory, create files <code class="highlighter-rouge">index.html</code>, <code class="highlighter-rouge">chart.js</code>, and <code class="highlighter-rouge">main.css</code>. Start by populating <code class="highlighter-rouge">index.html</code> with the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
	<span class="nt">&lt;head&gt;</span>
		<span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">'main.css'</span> <span class="na">rel=</span><span class="s">'stylesheet'</span> <span class="na">type=</span><span class="s">'text/css'</span><span class="nt">&gt;</span>
		<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">'https://fonts.googleapis.com/css?family=Roboto:800,600,400,300'</span> <span class="na">rel=</span><span class="s">'stylesheet'</span> <span class="na">type=</span><span class="s">'text/css'</span><span class="nt">&gt;</span>
		<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"//d3js.org/d3.v3.min.js"</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;&lt;/script&gt;</span>
		<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"//d3js.org/d3-queue.v3.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
		<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"//d3js.org/topojson.v1.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
	<span class="nt">&lt;/head&gt;</span>
	<span class="nt">&lt;body&gt;</span>
		<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"chart"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"pane-1"</span> <span class="na">class=</span><span class="s">"pane"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;/div&gt;</span>
			<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"pane-2"</span> <span class="na">class=</span><span class="s">"pane"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;/div&gt;</span>
		<span class="nt">&lt;/div&gt;</span>
	<span class="nt">&lt;/body&gt;</span>
	<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"chart.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>This creates the empty shells where we‚Äôll be rendering our data. If you recall the interactive graphic from the top of this post, <code class="highlighter-rouge">div#pane-1</code> with the blue top bar is where we put the map, and <code class="highlighter-rouge">div#pane-2</code> with the red top bar is where we put the census data for a selected zip code.</p>

<h4 id="displaying-the-data">Displaying the Data</h4>

<p>Since we want to make our final graphic responsive, the process by which we generate it is modular. One function is called to initialize it, performing all of the setup tasks that we only need to execute a single time. Then another function is called to render the graphic on page load. This function is also called any time the window size changes, updating any parameters linked to it. This all happens seamlessly as the window is scaled, with styling and a few layout tweaks made in CSS. Our modular <code class="highlighter-rouge">charts.js</code> follows this basic structure.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var Chart = (function(document,window,d3) {

	&lt;Define variables accessible to all functions&gt;
	&lt;Load data files&gt;

	function init(error, &lt;Data files&gt;) {

		&lt;Setup stuff that we only need to do once&gt;
		render();

	}

	function render() {

		&lt;Stuff we want to update every time the window size changes&gt;

	}

	return {

		render : render

	}

})(document,window,d3);

window.addEventListener('resize', Chart.render);
</code></pre></div></div>

<p>First we define all of the variables we‚Äôre going to want accessible across functions and use <a href="https://github.com/d3/d3-queue">d3-queue</a> to asynchronously load all of our data files (in this case, <code class="highlighter-rouge">us.json</code> and <code class="highlighter-rouge">orders_demos.csv</code>) before passing that data to our initialization function <code class="highlighter-rouge">init()</code>. We also define a function <code class="highlighter-rouge">type()</code> that we‚Äôll pass the .csv data to in a moment. It uses the Javascript unary operator <code class="highlighter-rouge">+</code> to convert the text fields to numbers and returns the converted data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var svg, map, csv, proj, path, nation, states, bubbles, tooltip, stats, width, height, padding, radius;

	d3.queue()
		.defer(d3.json, 'us.json')
		.defer(d3.csv, 'orders_demos.csv')
		.await(init);

		function type(data) {

			data.forEach(function(d) {

				d['Profit'] = +d['Profit'];
				d['Lat'] = +d['Lat'];
				d['Lng'] = +d['Lng'];
				d['Population'] = +d['Population'];
				d['Median-Age'] = +d['Median-Age'];
				d['Race-White'] = +d['Race-White'];
				d['Median-Household-Income'] = +d['Median-Household-Income'];
				d['Bachelors-Degree'] = +d['Bachelors-Degree'];
				d['Graduate-Degree'] = +d['Graduate-Degree'];

			});

			return data;

		}
</code></pre></div></div>

<p>Now our <code class="highlighter-rouge">init()</code> functions takes in our data files and passes the order data to <code class="highlighter-rouge">type()</code> to properly format the number fields. We append an <code class="highlighter-rouge">svg</code> to <code class="highlighter-rouge">div#pane-1</code> where we‚Äôll be drawing the map. We define our geographic projection and path, and append paths to the <code class="highlighter-rouge">svg</code> for the full shape of the US, as well as the shapes of the individual states. You‚Äôll notice that here we pass in the data file and assign classes (for later styling with CSS) for each path but don‚Äôt yet link our <code class="highlighter-rouge">path</code> variable to the <code class="highlighter-rouge">"d"</code> attribute. We‚Äôll do this in the <code class="highlighter-rouge">render()</code> function after updating the projection based on the window size.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function init(error, us, orders) {

		if (error) return console.error(error);

		map = us;
		csv = type(orders);

		svg = d3.select('#pane-1')
			.append('svg');

		proj = d3.geo.albersUsa()

		path = d3.geo.path();

		nation = svg.append("path")
			.datum(topojson.feature(map, us.objects.nation))
			.attr("class", "land")

		states = svg.append("path")
			.datum(topojson.mesh(map, us.objects.states, function(a, b) { return a !== b; }))
			.attr("class", "border border--state")
</code></pre></div></div>

<p>Continuing in the <code class="highlighter-rouge">init()</code> function, we initialize our bubbles and tooltip in the same way, as well as the statistics panel that we put in <code class="highlighter-rouge">div#pane-2</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bubbles = svg.selectAll("circle")
	.data(csv)
	.enter()
	.append("circle")
		.attr("class", "bubble")
		.attr("class", function(d) {
			return "bubble bubble-" + d.Zipcode.substring(0,1);
		})

	bubbles.sort(function(a, b) { return b.Profit - a.Profit; })

	tooltip = d3.select("body")
		.append("div")
		.attr("class", "tooltip")
		.style("opacity", 0);

	stats = d3.select("#pane-2")
		.append("div")
		.attr("class", "stats")
		.html("&lt;h3&gt;Click on a zip code bubble to view demographic statistics for the area...&lt;/h3&gt;")
</code></pre></div></div>

<p>The last thing we do in <code class="highlighter-rouge">init()</code> is define the hover and click functions for the bubbles. Following the same convention used for the other items, we assign everything (including demographic data) that isn‚Äôt a function of the window size, saving those properties for the <code class="highlighter-rouge">render()</code> function. With all of the initialization actions called, we end the function by calling <code class="highlighter-rouge">render()</code> to complete the initial rendering of our visualization.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bubbles.on("mouseover", function(d) {
	tooltip.transition()
		.duration(500)
		.style("opacity", .7);
	var tip = "&lt;strong&gt;Zip Code:&lt;/strong&gt; " + d.Zipcode + "&lt;br/&gt;";
	tip = tip + "&lt;strong&gt;Profit:&lt;/strong&gt; $" + d3.format(",.0f")(d.Profit);
	tooltip.html(tip)
		.style("left", (d3.event.pageX) + "px")
		.style("top", (d3.event.pageY) + "px");
})
.on("mouseout", function(d) {
	tooltip.transition()
		.duration(500)
		.style("opacity", 0);
})
.on("click", function(d) {
	var activeClass = "active";
	var alreadyIsActive = d3.select(this).classed(activeClass);
	svg.selectAll(".bubble")
		.classed(activeClass, false);
	d3.select(this).classed(activeClass, !alreadyIsActive);
	var stat;
	if (alreadyIsActive == false) {
		stat = "&lt;div class='stat'&gt;Zipcode&lt;h2&gt;" + d.Zipcode + "&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Profit&lt;h2&gt;$" + d3.format(",.0f")(d.Profit) + "&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Population&lt;h2&gt;" + d3.format(",.0f")(d.Population) + "&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Race (White)&lt;h2&gt;" + d3.format(",.1f")(d['Race-White']) + "%&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Median Age&lt;h2&gt;" + d3.format(",.1f")(d['Median-Age']) +  "&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Median Household Income&lt;h2&gt;$" + d3.format(",.0f")(d['Median-Household-Income']) + "&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Bachelors Degree (Adults 25+)&lt;h2&gt;" + d3.format(",.1f")(d['Bachelors-Degree']) + "%&lt;/h2&gt;&lt;/div&gt;";
		stat = stat + "&lt;div class='stat'&gt;Graduate Degree (Adults 25+)&lt;h2&gt;" + d3.format(",.1f")(d['Graduate-Degree']) + "%&lt;/h2&gt;&lt;/div&gt;";
	} else {
		stat = "&lt;h3&gt;Click on a zip code bubble to view demographic statistics for the area...&lt;/h3&gt;";
	}
	stats.html(stat);
});

render();
</code></pre></div></div>

<p>Since the first thing we do in the <code class="highlighter-rouge">render()</code> function is call <code class="highlighter-rouge">updateDimensions()</code>, I‚Äôll show that first. It simply calls a function to read the width of the parent element <code class="highlighter-rouge">div#pane-1</code> of the map, and updates the <code class="highlighter-rouge">width</code> and <code class="highlighter-rouge">height</code> variables, accounting for padding and maintaining a fixed aspect ratio (defined here at 3:2).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function updateDimensions() {

	var wide = getElementContentWidth('pane-1');
	padding = 10;
	width =  wide - 2 * padding;
	height = wide / 1.5 - 2 * padding;

}

function getElementContentWidth(element) {
	return document.getElementById(element).clientWidth;
}
</code></pre></div></div>

<p>After updating the drawing dimensions, <code class="highlighter-rouge">render()</code> updates the bubble scaling, assigns the proper size to the <code class="highlighter-rouge">svg</code>, and updates the projection to the drawing size. With these items updated to scale everything properly, we‚Äôre now able to assign the remaining data attributes to the paths and bubbles, which completes the process of rendering them in the drawing.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function render() {

	updateDimensions();

	radius = d3.scale.sqrt()
		.domain([0, d3.max(csv, function(d) { return d.Profit })])
		.range([0, width/40]);

	svg
		.attr('width', width)
		.attr('height', height);

	proj
		.scale(width)
		.translate([width / 2 - padding, height / 2 - padding]);

	path
		.projection(proj);

	nation
		.attr('d', path)

	states
		.attr('d', path)

	bubbles
		.attr("cx", function (d) {
			return proj([d.Lng, d.Lat])[0];
		})
		.attr("cy", function (d) {
			return proj([d.Lng, d.Lat])[1];
		})
		.attr("r", function (d) {
			return radius(d.Profit);
		})

}
</code></pre></div></div>

<h4 id="visual-styling">Visual Styling</h4>

<p>At this point, everything we‚Äôve rendering is unstyled. We‚Äôve defined the locations and sizes of elements on the page, but properties like fill color and line weight are not yet defined. While we could have done this by defining additional attributes or styles in the course of rendering, I prefer to keep styling in a separate .css file. Instead, we‚Äôve assigned unique classes to elements that we can then target with style rules. For example, based on the first number of each zip code, we‚Äôve assigned a corresponding class like <code class="highlighter-rouge">bubble-1</code> or <code class="highlighter-rouge">bubble-2</code> to shade bubbles based on their geographic region. Rather than laying out the entire <code class="highlighter-rouge">main.css</code> document, here are the first few lines that style the parent divs <code class="highlighter-rouge">div#chart</code>, <code class="highlighter-rouge">div.pane</code>, <code class="highlighter-rouge">div#pane-1</code>, and <code class="highlighter-rouge">div#pane-2</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#chart {
	max-width: 1200px;
	height: auto;
	overflow: auto;
	padding: 20px;
	background: rgb(210,210,210);;
	margin: 0 auto;
	display: block;
}

.pane {
	height: auto;
	overflow: auto;
	display: block;
	float: left;
	padding: 10px;
	box-sizing: border-box;
}

#pane-1 {
	width: 75%;
}

#pane-2 {
	width: 25%;
}
</code></pre></div></div>

<p>If you‚Äôre interested in looking through the entire <code class="highlighter-rouge">main.css</code> document or the full source code for everything covered in this example, you can <a href="https://github.com/bdharva/bdharva.github.io/tree/master/assets/blog/d3-mapping-sales">check it out</a> on my Github.</p>
:ET